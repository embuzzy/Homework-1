---
title: "homework scratch"
author: "Emily Buzzelli"
date: "August 8, 2018"
output: html_document
---
library(ggplot2)

marketing <- read.csv("social_marketing.csv", row.names=1)

#Remove spam, adult, uncategorized & chatter -- these aren't going to give me insights
#(The assumption with removing adult is that these people are trolls/spammers/bots)
marketing1 = marketing[,-c(1,5,35,36)]

# First normalize phrase counts to phrase frequencies.
# (often a sensible first step for count data, before z-scoring)
Z = marketing1/rowSums(marketing1)

#figure out who is posting the most & give some scores for other categories
comment_num = data.frame(rowSums(marketing))
comment_bucket = rep('<50', dim(comment_num)[1])
comment_bucket[comment_num$rowSums.marketing.>50]='>50'
comment_num = cbind(comment_num,comment_bucket)


#PCA
set.seed(8418)
pc2 = prcomp(Z, scale=TRUE, rank=2)
loadings = pc2$rotation
scores = pc2$x


#Question 1 - where do the observations land in PC space?
qplot(scores[,1], scores[,2], color=comment_num$comment_bucket, xlab='Component 1', ylab='Component 2')

##Not super helpful to look at number of tweets to try to separate people.


# Question 2: how are the individual PCs loaded on the original variables?
# The top categories associated with each component
o1 = order(loadings[,1], decreasing=TRUE)
colnames(Z)[head(o1,10)]
colnames(Z)[tail(o1,10)]

o2 = order(loadings[,2], decreasing=TRUE)
colnames(Z)[head(o2,10)]
colnames(Z)[tail(o2,10)]



##It looks like PCA is separating in the first component by age -- the resulting categories = religion, parenting, family, news, politics vs. college_uni, online_gaming, photo_sharing, personal_fitness, etc.  The second component seems to indicate a separation b/t people who care a lot about how they look/fitness vs. people who are interested in more "academic" types of pursuits.  Lets try giving some more scores based on these results...

young_score = rep(0, dim(comment_num)[1])
young_score = rowSums(marketing[,c(15,17,14,28,4,23,33,32,16)])
old_score = rep(0, dim(comment_num)[1])
old_score = rowSums(marketing[,c(7,27,29,10,25,13,8,24)])

brain_score = rep(0, dim(comment_num)[1])
brain_score = rowSums(marketing[,c(21,2,13,14,4,6)])

beauty_score = rep(0, dim(comment_num)[1])
beauty_score = rowSums(marketing[,c(16,32,23,9,19,28,7)])

#Add to dataset
marketing2 = cbind(marketing,young_score, old_score, brain_score,beauty_score)
marketing2 = marketing2[,-c(1,5,35,36)]
Z2 = marketing2/rowSums(marketing2)

#Now let's replot with this new "category" & see if we find anything interesting
qplot(scores[,1], scores[,2], color=Z2$young_score, xlab='Component 1', ylab='Component 2')
qplot(scores[,1], scores[,2], color=Z2$brain_score, xlab='Component 1', ylab='Component 2')
qplot(scores[,1], scores[,2], color=Z2$beauty_score, xlab='Component 1', ylab='Component 2')
qplot(scores[,1], scores[,2], color=Z2$old_score, xlab='Component 1', ylab='Component 2')


##This seems to give us some insight into the types of people who follow NutritionH2O





##Now try hierarchical clustering

# Center/scale the data
marketing_scaled <- scale(marketing, center=TRUE, scale=TRUE) 

# Form a pairwise distance matrix using the dist function
marketing_distance_matrix = dist(marketing_scaled, method='euclidean')


# Now run hierarchical clustering
hier_market = hclust(marketing_distance_matrix, method='average')


# Plot the dendrogram
plot(hier_market, cex=0.8)

# Cut the tree into 5 clusters
cluster1 = cutree(hier_market, k=5)
summary(factor(cluster1))

# Examine the cluster members
which(cluster1 == 1)
which(cluster1 == 2)
which(cluster1 == 3)


# Using single ("single") linkage instead
hier_market2 = hclust(marketing_distance_matrix, method='complete')

# Plot the dendrogram
plot(hier_market2, cex=0.8)
cluster2 = cutree(hier_market2, k=5)
summary(factor(cluster2))

# Examine the cluster members
which(cluster2 == 1)
which(cluster2 == 2)
which(cluster2 == 3)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r echo=FALSE, fig.width = 8, fig.height=4}
# Look at close-to-close changes
plot(all_returns[,4],col = "black",ylim = c(-.3, .3), main = "EEM")
```


```{r echo=FALSE, fig.width = 8, fig.height=4}
# Look at close-to-close changes
plot(all_returns[,5],col = "red",ylim = c(-.3, .3), main = "VNQ")
```

```{r echo=FALSE, fig.width = 8, fig.height=4}
# Look at close-to-close changes
plot(all_returns[,3],col = "cyan",ylim = c(-.3, .3), main = "SPY")
```

```{r echo=FALSE, fig.width = 8, fig.height=4}
# Look at close-to-close changes
plot(all_returns[,1],col = "green",ylim = c(-.3, .3), main = "TLT")
```

```{r echo=FALSE, fig.width = 8, fig.height=4}
# Look at close-to-close changes
plot(all_returns[,2],col = "blue",ylim = c(-.3, .3), main = "LQD")
```


##Green Buildings





#








#Lets see the proportion of green buildings that have amenities


#

#


#





#


#
  




plot(onlygreen$cluster_compare, onlygreen$leasing_rate)



#Green buildings tend to be nicer


#newer buildings v. rent
qplot(greenbuildings$green_rating, greenbuildings$class_a, color=greenbuildings$green_rating, xlab='size', ylab='rent')


## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
